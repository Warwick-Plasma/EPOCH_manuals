\documentclass[12pt]{article}
%\usepackage{url,graphicx,tabularx,array}
\usepackage[hmargin=.47in,vmargin=0.5in,nohead]{geometry}
\setlength{\footskip}{20pt}
% \usepackage{color}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{ltxtable}
\setlength{\heavyrulewidth}{0.09em}
\newcommand{\ver}{1}
\newcommand{\rev}{0}
\newcommand{\version}{{{\ver}.{\rev}}}


\begin{document}

\begin{center}
{\huge\bfseries Description of the SDF File Format for
  Version {\version}}\\[0.4cm]
{\Large Keith Bennett}\\[0.1cm]
{\large\today}\\[0.4cm]
\end{center}

% \author{Keith Bennett}

\section{Introduction}
The CFSA group at the University of Warwick actively maintains several
complex codebases and has plans to expand the variety of codes in the future.
To ease maintenance and facilitate sharing of data between codes it is
beneficial for all of these codes to output results to the same file format.
Such a format needs to be ``self-describing'', which means that each variable
dumped to the file is accompanied by a description of the variable and enough
information for a visualisation tool to know how to display its contents in a
meaningful way.

There already exists a wide variety of output formats but all have been found
to have some shortcomings. In particular, none of the popular file formats
benchmarked were found to be as fast for reading and writing to disk as
a native MPI-IO implementation. For this reason, we have chosen to design our
own format which is as simple as possible whilst providing the basic features
we require. An additional benefit to this approach is that it reduces the
number of dependencies required to make use of the format.

We have chosen to call this format ``SDF'' which stands for ``Self Describing
Format''. Files written to this format will have the suffix ``.sdf''.

This document should fully describe the contents of an SDF version {\version}
file. From this it should be possible to write a compliant library for
reading and writing SDF files.

\section{File Structure}

The layout of an SDF file is as follows:\\

\noindent
\hspace*{10mm}File header\\
\hspace*{15mm}Block header \#1\\
\hspace*{20mm}Block metadata \#1\\
\hspace*{25mm}Block data \#1\\
\hspace*{15mm}Block header \#2\\
\hspace*{20mm}Block metadata \#2\\
\hspace*{25mm}Block data \#2\\
\hspace*{25mm}\vdots\\
\hspace*{15mm}Block header \#1\\
\hspace*{20mm}Block metadata \#1\\
\hspace*{15mm}Block header \#2\\
\hspace*{20mm}Block metadata \#2\\
\hspace*{25mm}\vdots\\

The file header contains basic information about the simulation, number
of blocks contained in the file and the location of the first block header.
Each block header knows the location of the following block header.

In the outline shown above it can be seen that the block headers and metadata
are repeated at the end of the file. An older version of the format just
wrote the header and metadata for each block followed by the data for
that block and then moved on to the next block. Whilst this makes logical
sense, it has an adverse affect on performance. It is often the case that
the only data required from a file is a list of its contents. A good example
of this is a visualisation tool such as VisIt. The first thing that it
does is to scan the contents of a file so that it can build a list of menu
entries. For this purpose it is much better to have all of the header and
metadata in a contiguous block without having to skip the data block each
time. This can be achieved by placing an extra copy of the metadata at
the end of the file.

\section{File Header}
Every SDF file starts with a header containing basic global information
about the file and its contents. The data written to the file header in
version {\version} of the format is as follows:\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule
%\endhead
%  \\\caption{SDF file header contents}\\
%\endfoot

  0 & char 3 & sdf & Always ``SDF'' in a valid file
  \\\midrule

  3 & int 4 & endianness & An integer used to indicate the endianness of the
  file. This is a fixed constant which should never need to be changed.
  It should written as 0x0f0e0201 (16911887) on little-endian machines and
  0x01020e0f on big-endian machines. An opposite-endian machine will read
  it as being 252576257.
  \\\midrule

  7 & int 4 & block\_header\_length & The length in bytes of the block
  headers. This is a fixed length which excludes the individual block's
  metadata.
  \\\midrule

  11 & int 4 & sdf\_version & Version number. If this is higher than the
  version of the reader then the reader MUST fail as the file will almost
  certainly not be readable.
  If the version of the file is higher than version {\ver} then the
  items listed here may not correspond to the contents of the file header
  at all.
  \\\midrule

  15 & int 4 & sdf\_revision & Revision number. If this is higher than the
  version of the reader then it should try to continue. Revision changes only
  add data to structures, never remove or move data.
  If the revision of the file is higher than revision {\rev} then there
  may be more items than are listed here but these should not affect the
  ability to properly read the file.
  \\\midrule

  19 & int 8 & first\_block\_location & The location of the first metadata
  block relative to the start of the file. If a reader wishes to
  read the file by reading metadata followed by data on a block by block
  basis, then it should seek to this position to locate the first block header.
%  \\\midrule
\end{tabularx}
\end{center}
\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  27 & int 8 & summary\_info\_location & The location of the first metadata
  block in the summary section relative to the start of the file. If a reader
  wishes to scan the contents of a file before reading any data then it should
  seek to this position to locate the first block header.
  \\\midrule

  43 & int 8 & summary\_info\_size & The total size of all the metadata
  written to the summary.
  \\\midrule

  51 & int 4 & nblocks & The number of blocks in the file. When writing this
  should be zero until the file is written and closed.
  \\\midrule

  55 & char 32 & code\_name & The name of the program which generated the
  file. eg. ``Epoch2d''
  \\\midrule

  91 & int 4 & code\_io\_version & A revision number for the program's output.
  The code I/O version is written in case the semantics of the output change in
  such a way that the code cannot interpret the data based on the
  self-describing semantics alone. It should rarely be required.
  \\\midrule

  95 & int 4 & jobid1 & This integer and the one which follows uniquely
  identify the simulation which wrote the data. All output files created by
  a simulation will have the same jobid flags. If a job is restarted then
  the jobid will be retained. Currently the time in seconds
  and milliseconds is used but this may change.
  \\\midrule

  99 & int 4 & jobid2 & See above
  \\\midrule

  103 & int 4 & step & The simulation step number.
  \\\midrule

  107 & real 8 & time & The simulation time.
  \\\midrule

  115 & int 4 & string\_length & All long strings in the file are of this
  length. Allocate this much space for all future string variables. See below
  for further details.
  \\\midrule

  119 & char 1 & restart\_flag & A single byte that is equal to one if this
  file can be used as a restart dump and zero otherwise.
  \\\midrule

  120 & char 1 & subdomain\_file & A single byte that is equal to one if this
  file represents a single subdomain and zero if it contains data for the
  entire simulation domain. Although not currently supported, a future version
  of the I/O library will be able to write one output file per process. This
  flag will then be used to dermine if the file was generated in such a manner.
  \\\midrule

  121 &
\end{tabularx}
\end{center}\vspace{10pt}

There are two fixed character lengths used in the dump. They are fixed to
ease support for FORTRAN which has fairly weak string handling support.
Short strings are written using CHARACTER*32, chosen because 31 is the
maximum identifier length in standard FORTRAN. The second length is
``String length'', which can be chosen at run time but remains fixed
within a single dump file. It defaults to 60.
For the sake of brevity, this length will be referred to as ``s'' throughout
the remainder of this document.

\section{Block Headers}
All block headers are exactly the same size and contain the same information.
They contain information which is required by all blocks to identify
their contents, such as an identifier, data location, etc.
They also contain a blocktype which is used to determine the size and contents
of the metadata section since it is different for each block type.
If there are any entries of variable size in the metadata section then the
information required to allocate memory must be contained in the block header.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  0 & int 8 & next\_block\_location & The location of the next metadata
  block relative to the start of the file.
  \\\midrule

  8 & int 8 & data\_location & The location of the data for the current block.
  Note that the data can be placed anywhere in the file and is not at a fixed
  location relative to the metadata.
  \\\midrule

  16 & int 4 & blocktype & The type of the block. This determines the contents
  of the metadata section. If a reader does not have support for a given
  blocktype then it can just skip to the next block using next\_block\_location.
  \\\midrule

  20 & char 32 & block\_id & The block identifier. This is a short string
  which uniquely identifies the block within the file.
  \\\midrule

  52 & char s & block\_name & The display name used for the variable. This
  is the name presented to a user in a visualisation tool so it must be
  human readable and descriptive of the variable.
  \\\midrule

  52+s & int 4 & datatype & The basic datatype of the variable. This is
  specified using a named constant, described later.
  \\\midrule

  56+s & int 4 & ndims & The number of dimensions of the variable if
  it is an array. If the variable is not an array then this is equal to 1.
  \\\midrule

  60+s & int 8 & data\_size & The size of the data section in the current block.
  This can be used together with ``datatype'' to determine the total number
  of elements if the variable is an array.
  \\\midrule

  68+s &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``s'' is the size of ``string\_length'' as specified in the file header.
For the sake of brevity, the value of ``ndims'' will be referred to as ``n''
throughout the remainder of this document.

The block-id uniquely identifies a block with a machine readable identifier.
Typically, this is just the variable name (in lower case). When data is
presented using VisIt and other tools, the ``name'' field is used. This
allows the presentation of data names to change without breaking code which
relies on a fixed name. Previous versions of the format also used a separate
``class'' name. Such groupings can easily be accomplished by separating
components using a ``/'' symbol. Since this convention allows greater
flexibility, the class name has been dropped.

The possible values for ``blocktype'' are itemised below. They are defined
as constants in the SDF Fortran module, as indicated by the ``c\_'' prefix.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{lcX}
  Constant name & Value & Description
  \\\toprule

  c\_blocktype\_scrubbed & -1 & Deleted block. Code should ignore.
  \\\midrule

  c\_blocktype\_null & 0 & Unknown block type. This is an error.
  \\\midrule

  c\_blocktype\_mesh & 1 & Block describing a mesh or grid.
  \\\midrule

  c\_blocktype\_point\_mesh & 2 & Block describing a point mesh or grid.
  \\\midrule

  c\_blocktype\_mesh\_variable & 3 & Block describing a variable on a mesh.
  \\\midrule

  c\_blocktype\_point\_mesh\_variable & 4 & Block describing a variable on
  a point mesh.
  \\\midrule

  c\_blocktype\_constant & 5 & A simple constant not associated with a grid.
  \\\midrule

  c\_blocktype\_array & 6 & A simple array not associated with a grid.
  \\\midrule

  c\_blocktype\_particle\_family & 7 & Information about a particle family.
  \\\midrule

  c\_blocktype\_info & 8 & Information about the simulation.
  \\\midrule

  c\_blocktype\_source & 9 & Embedded source code block.
  \\\midrule

  c\_blocktype\_stitched\_tensor & 10 & List of blocks to combine as a tensor
  or vector.
  \\\midrule

  c\_blocktype\_stitched\_material & 11 & List of blocks to combine as a
  multi-material mesh.
  \\\midrule

  c\_blocktype\_stitched\_species & 12 & List of blocks to combine as a
  species mesh. This is similar to a multi-material mesh except there is
  no interface in a mixed cell.
\end{tabularx}
\end{center}\vspace{10pt}

The possible values for ``datatype'' are itemised below.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{lcX}
  Constant name & Value & Description
  \\\toprule

  c\_datatype\_null & 0 & No datatype specified. This is an error.
  \\\midrule

  c\_datatype\_integer4 & 1 & 4-byte integers.
  \\\midrule

  c\_datatype\_integer8 & 2 & 8-byte integers.
  \\\midrule

  c\_datatype\_real4 & 3 & 4-byte floating point (ie. single precision).
  \\\midrule

  c\_datatype\_real8 & 4 & 8-byte floating point (ie. double precision).
  \\\midrule

  c\_datatype\_real16 & 5 & 16-byte floating point (ie. quad precision).
  \\\midrule

  c\_datatype\_character & 6 & 1-byte characters.
  \\\midrule

  c\_datatype\_logical & 7 & Logical variables. (Represented as 1-byte
  characters).
  \\\midrule

  c\_datatype\_other & 8 & Unspecified datatype. The type of data in the block
  must be inferred from the block type.
\end{tabularx}
\end{center}\vspace{10pt}

\section{Block Types}

In this section we describe the metadata and data contents for each of
the possible block types. Note that as the format evolves more block types
may be added, but that should not affect the ability of old readers to
read the only the block types which they know about.
Since the metadata follows on from the block header, the offset given
starts ``m'' bytes on from the start of the block. The value of ``m''
is that given by ``block\_header\_length'' in the file header. Note that
the metadata may not necessarily continue directly after the last entry
read from the block header, since the block header size may change in
future revisions. For this reason you should always seek to a position
``m'' bytes after the start of the block before reading the block metadata.

\subsection{c\_blocktype\_mesh and c\_blocktype\_point\_mesh}

Since grid based meshes and point meshes are quite similar, we will describe
them both here. A mesh defines the locations at which variables are defined.
Since the geometry of a problem is fixed and most variables will be defined
at positions relative to a fixed grid, it makes sense to write this position
data once in its own block. Each variable will then refer to one of these
mesh blocks to provide their location data.

Both grid based meshes and point meshes write the same basic information
at the start of the header and this common metadata is given below.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  m & real 8 & mult & The normalisation factor applied to the variable data.
  \\\midrule

  m+8 & char 32 & units & The units for this variable after the normalisation
  factor has been applied.
  \\\midrule

  m+40 & int 4 & geometry\_type & The geometry of the simulation.
  \\\midrule

  m+44 & real 8n & minval & The minimum coordinate values in each direction.
  \\\midrule

  m+44+8n & real 8n & maxval & The maximum coordinate values in each
  direction.
  \\\midrule

  m+44+16n &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' as specified in the file
header and ``n'' is the number of dimensions as specified in the block header.

The ``geometry\_type'' specifies the geometry of the simulation and it can
take one of the following values:\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{lcX}
  Constant name & Value & Description
  \\\toprule

  c\_geometry\_cartesian & 0 & Cartesian geometry.
  \\\midrule

  c\_geometry\_cylindrical & 1 & Cylindrical geometry.
  \\\midrule

  c\_geometry\_spherical & 2 & Spherical geometry.
\end{tabularx}
\end{center}\vspace{10pt}

At the end of the metadata, grid based meshes and point meshes contain
differing information. For a grid based mesh (``c\_blocktype\_mesh'')
the last items in the header are as follows:\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  m+44+16n & int 4n & dims & The number of grid points in each dimension.
  \\\midrule

  m+44+20n &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' as specified in the file
header and ``n'' is the number of dimensions as specified in the block header.

The data is then written at the location specified by ``data\_location'' in
the block header. Note that this will not always be in the position immediately
following the block header so a reader must always seek to this location
explicitly.

For a grid based mesh, the data written is the locations of node points for
the mesh in each of the simulation dimensions. Therefore for a
3d simulation of resolution (nx,ny,nz), the data will consist of 
a 1d array of X positions with (nx+1) elements followed by a 1d array of
Y positions with (ny+1) elements and finally a 1d array of Z positions with
(nz+1) elements. Here the resolution specifies the number of simulation cells
and therefore the nodal values have one extra element. In a 1d or 2d simulation,
you would write only the X or X and Y arrays respectively.

For a point mesh (``c\_blocktype\_point\_mesh'') the last items in the header
are as follows:\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  m+44+16n & int 8 & np & Number of particles
  \\\midrule

  m+52+16n &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' as specified in the file
header and ``n'' is the number of dimensions as specified in the block header.

The data written is the locations of each point. For a 3d simulation the
(x,y,z) coordinates are written for each point in turn. Similarly, for
1d and 2d simulations we write the (x) and (x,y) coordinates respectively.
Thus, for a 3d simulation, if we define the first point as having coordinates
(x1,y1,x1) and the second point as (x2,y2,z2), etc. then the data written
to file is a 1d array with elements (x1,y1,z1,x2,y2,z2, ... ,xp,yp,zp), where
``p'' corresponds to the number of points in the mesh.

\subsection{c\_blocktype\_mesh\_variable and c\_blocktype\_point\_variable}

As with the mesh data described previously, the grid based variables and
point variables are quite similar so we will describe them both here.
Both blocktypes describe a variable which is located relative to the points
given in a mesh block.

Both grid based variables and point variables write the same basic information
at the start of the header and this common metadata is given below.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  m & real 8 & mult & The normalisation factor applied to the variable data.
  \\\midrule

  8+m & char 32 & units & The units for this variable after the normalisation
  factor has been applied.
  \\\midrule

  40+m & char s & mesh\_name & The name of the mesh relative to which this
  block's data is defined.
  \\\midrule

  40+m+s &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' and``s'' is the size of
``string\_length'' both specified in the file header.

At the end of the metadata, grid based variables and point variables contain
differing information. For a grid based variable
(``c\_blocktype\_mesh\_variable'') the last items in the header are as
follows:\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  40+m+s & int 4n & dims & The number of grid points in each dimension.
  \\\midrule

  40+m+s+4n & int 4 & stagger & The dimensions of the array.
  \\\midrule

  44+m+s+4n &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' and``s'' is the size of
``string\_length'' both specified in the file header.
``n'' is the number of dimensions as specified in the block header.

The mesh associated with a variable is always node-centred, ie. the values
written as mesh data specify the nodal values of a grid. Variables may be
defined at points which are offset from this grid due to grid staggering in
the code. The ``stagger'' entry specifies where the variable is defined
relative to the mesh. Since we have already defined the number of points
that the associated mesh contains, this determines how many points are required
to display the variable.

The ``stagger'' entry can take one of the following values:\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{lcX}
  Constant name & Value & Description
  \\\toprule

  c\_stagger\_cell\_centre & 1 & Cell centred. At the midpoint between nodes.
  Implies an (nx,ny,nz) grid.
  \\\midrule

  c\_stagger\_vertex & 2 & Node centred. At the same place as the mesh.
  Implies an (nx+1,ny+1,nz+1) grid.
  \\\midrule

  c\_stagger\_face\_x & 3 & Face centred in X. Located at the midpoint between
  nodes on the Y-Z plane.
  Implies an (nx+1,ny,nz) grid.
  \\\midrule

  c\_stagger\_face\_y & 4 & Face centred in Y. Located at the midpoint between
  nodes on the X-Z plane.
  Implies an (nx,ny+1,nz) grid.
  \\\midrule

  c\_stagger\_face\_z & 5 & Face centred in Z. Located at the midpoint between
  nodes on the X-Y plane.
  Implies an (nx,ny,nz+1) grid.
  \\\midrule

  c\_stagger\_edge\_x & 6 & Edge centred along X. Located at the midpoint
  between nodes along the X-axis.
  Implies an (nx,ny+1,nz+1) grid.
  \\\midrule

  c\_stagger\_edge\_y & 7 & Edge centred along Y. Located at the midpoint
  between nodes along the Y-axis.
  Implies an (nx+1,ny,nz+1) grid.
  \\\midrule

  c\_stagger\_edge\_z & 8 & Edge centred along Z. Located at the midpoint
  between nodes along the Z-axis.
  Implies an (nx+1,ny+1,nz) grid.
\end{tabularx}
\end{center}\vspace{10pt}

The data is then written at the location specified by ``data\_location'' in
the block header. Note that this will not always be in the position immediately
following the block header so a reader must always seek to this location
explicitly.

For a grid based variable, the data written contains the values of the given
variable at each point on the mesh. This is in the form of a 1d, 2d or 3d
array depending on the dimensions of the simulation. The size of the array
depends on the size of the associated mesh and the grid staggering as
indicated above. It corresponds to the values written into the ``dims''
array written for this block.

For a point variable (``c\_blocktype\_point\_variable'') the last items in the
header are as follows:\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  40+m+s & int 8 & np & Number of particles
  \\\midrule

  48+m+s &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' and``s'' is the size of
``string\_length'' both specified in the file header.

Similarly to the grid based variable, the data written contains the values of
the given variable at each point on the mesh. Since each the location of
each point in space is known fully, there is no need for a stagger variable.
The data is in the form of a 1d array with ``np'' elements.

\subsection{c\_blocktype\_constant}

This block is used for writing a simple constant to the file. Since the
data written is small, there is no need for a separate data block and
the value is just written into the metadata section.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  m & type t & data & The actual constant to be written.
  \\\midrule

  m+t &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' as specified in the file
header and ``t'' is the size of the datatype specified in the block header.

\subsection{c\_blocktype\_array}

This block is used for writing a simple array to the file. This array
is not associated with any mesh and therefore cannot be plotted on a
spatial grid.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  m & int 4n & dims & The dimensions of the array to be written.
  \\\midrule

  m+4n & type t*e & data & The actual array data.
  \\\midrule

  m+4n+t*e &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' as specified in the file
header.  ``n'' is the number of dimensions, ``t'' is the size of the datatype
and ``e'' is the number of elements all specified in the block header.

\subsection{c\_blocktype\_particle\_family}

\subsection{c\_blocktype\_info}

This block contains information about the code which was used to generate
the SDF file and further details relating to the simulation, such as
hardware on which it was run, etc.\\

\begin{center}
\begin{tabularx}{0.9\textwidth}[!hbt]{cclX}
  Offset & Datatype & Variable & Description\\
  (bytes) & \& size & name &
  \\\toprule

  m & int 4 & code\_version & The version of the code.
  \\\midrule

  4+m & int 4 & code\_revision & The revision of the code.
  \\\midrule

  8+m & char s & commit\_id & The revision control commit ID for the code.
  \\\midrule

  8+m+s & char s & sha1sum & The SHA-1 checksum of the source code.
  \\\midrule

  8+m+2s & char s & compile\_machine & The machine name on which the code was
  compiled.
  \\\midrule

  8+m+3s & char s & compile\_flags & The compilation flags used when compiling
  the code.
  \\\midrule

  8+m+4s & int 8 & defines & A bitmask of the pre-processor define flags used.
  This is a 64-bit integer, so only 63 flags can be used in total.
  \\\midrule

  16+m+4s & int 4 & compile\_date & The time at which the code was compiled,
  written as seconds since the UNIX epoch.
  \\\midrule

  20+m+4s & int 4 & run\_date & The time at which the simulation first began
  running, written as seconds since the UNIX epoch.
  \\\midrule

  24+m+4s & int 4 & io\_date & The time at which this output file began writing,
  written as seconds since the UNIX epoch.
  \\\midrule

  28+m+4s &
\end{tabularx}
\end{center}\vspace{10pt}

Here, ``m'' is the size of ``block\_header\_length'' and``s'' is the size of
``string\_length'' both specified in the file header.

\subsection{c\_blocktype\_source}

This block contains the source code which was used to generate the binary
which generated this SDF file. It is written as one long stream of bytes.
In the current implementation, the byte stream consists of a gzipped
tar file which is uuencoded to form one long character string. No further
metadata is required to describe this output so the contents begin at
``data\_location''. This data is a 1d character array of size given by
``data\_size'' in the block header.


\subsection{c\_blocktype\_stitched\_tensor, \_material and \_species}

Variables in SDF files are written so that they correspond to spatial meshes
wherever possible. This means that variables which have multiple components,
such as tensors, are written with a separate block for each component. This
data is then ``stitched'' back together and a separate block is used to
instruct a reader as to which blocks need to be combined and how to combine
them. This improves flexibility since a block can be used in multiple different
ways. For example, you can have multi-material vectors and so on.

The ``stitched'' blocks just contain a list of all the blocks which need to
be combined an the number of dimensions in the resulting variable.
All of this data is small, so it is written as metadata and there is no
data block for any of the ``stitched'' blocks.


\section{Ideal sequence for reading SDF files}
This section details the sequence that an ideal SDF reader should follow to
parse a SDF file.
\begin{itemize}
\item Open the file.
\item Read the ``SDF'' string to confirm that this is a SDF file.
\item If the ``SDF'' string isn't found then exit.
\item Read the rest of the header info.
\item Check that the endianness flag has the value c\_endianness (16911887).
  If not, then this file was written on a different machine architecture.
  Either convert all the values read in from this point on or exit with an
  error message.
\item Check that the version is less than or equal to the version of the
  standard that the reader is written to.
\item If not then exit with an error message about getting a new reader.
\item Check that the revision is less than or equal to the revision of the
  standard that the reader is written to.
\item If not then print a warning message, but continue.
\item If the ``nblocks'' field is zero then exit since the file hasn't been
  finished yet.
\item If you wish to read the metadata followed by data for each block in
  turn, set the file pointer to ``first\_block\_location''. If instead you want
  to scan the contents of the file before reading any data, set the file
  pointer to ``summary\_info\_location''.
\item Loop over ``nblocks''
\item Skip this step for the first block. For all subsequent blocks, set the
  file pointer to ``next\_block\_location'' given in the block header for the
  previous block.
\item Store the current file pointer value as ``block\_start''.
\item Read the block header
\item Determine whether the reader can deal with the type of block which is
  described by the header. Also check for user request for this variable etc.
\item If not then the filepointer should be set to the value of
  ``next\_block\_location'' given in the block header and then cycle back to
  the start of the loop.
\item If you only require block information stored in the block header then
  it is valid to skip the remaining steps and return to the start of the loop.
\item Otherwise set the filepointer to be at ``block\_start +
  block\_header\_size''.
\item Read the block metadata for the correct type of block.
\item If you only require block metadata then it is valid to skip the
  remaining steps and return to the start of the loop VisIt plugin works in
  this way when populating the VisIt metadata server).
\item Move the filepointer to ``data\_location''.
\item Read the block data and return to the start of the loop.
\item After ``nblocks'' have been iterated, close the file.
\end{itemize}

Since there is no requirement on the order in which blocks are written into
the file, it is not possible to do sanity checks until the file has been
parsed once, so a good reader should then do the following checks
\begin{itemize}
\item Check that all the meshes which are requested by mesh variables exist. If
  one of the meshes doesn't exist print a warning message and if the code
  cannot cope without a mesh then drop the variable. The code should NOT fail
  at this point if it is possible to continue.
\item Check that the sizes of variables match the sizes of the associated
  meshes. If not then print a warning message and drop the variable. The code
  should NOT fail at this point if it's possible to continue.
\end{itemize}

\end{document}
